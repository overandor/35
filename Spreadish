#!/usr/bin/env python3
"""
Safer Immortal Trading Gladiator dashboard (read-only, defensive, env-secrets, backoff)
"""
!pip install ta
import os
import time
import math
import random
import logging
from datetime import datetime
import ccxt
import numpy as np
import pandas as pd
from rich.console import Console
from rich.table import Table
from rich.live import Live
from rich.layout import Layout
import ta

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("gladiator")

console = Console()

# Secrets from environment (safe default: no keys => public endpoints)
API_KEY = os.getenv("GATE_API_KEY")
API_SECRET = os.getenv("GATE_API_SECRET")

exchange = ccxt.gateio({
    'apiKey': API_KEY or "",
    'secret': API_SECRET or "",
    'enableRateLimit': True,
    # optionally tweak timeout
})
# Use a short helper to respect exchange.rateLimit
def sleep_rate_limit():
    try:
        ms = getattr(exchange, "rateLimit", 1000)
        time.sleep(max(ms / 1000.0, 0.05))
    except Exception:
        time.sleep(0.1)

# -------- utilities with backoff & defensive checks --------
def safe_call(fn, *a, retries=3, backoff=0.5, **kw):
    for attempt in range(1, retries + 1):
        try:
            res = fn(*a, **kw)
            sleep_rate_limit()
            return res
        except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.RequestTimeout) as e:
            logger.warning("Network/Exchange error (attempt %s/%s): %s", attempt, retries, e)
            time.sleep(backoff * attempt)
        except Exception as e:
            logger.exception("Unexpected error in safe_call: %s", e)
            return None
    return None

def safe_fetch_ticker(symbol):
    return safe_call(exchange.fetch_ticker, symbol)

def safe_fetch_ohlcv(symbol, timeframe='1h', limit=100):
    return safe_call(exchange.fetch_ohlcv, symbol, timeframe, None, limit)

def safe_fetch_order_book(symbol, limit=50):
    return safe_call(exchange.fetch_order_book, symbol, limit=limit)

def calculate_rsi_safe(prices, period=14):
    if not prices or len(prices) < period:
        return None
    try:
        series = pd.Series(prices)
        rsi = ta.momentum.RSIIndicator(series, window=period).rsi().iloc[-1]
        if math.isnan(rsi):
            return None
        return float(rsi)
    except Exception as e:
        logger.debug("RSI calc error: %s", e)
        return None

def calculate_order_book_depth_safe(symbol):
    ob = safe_fetch_order_book(symbol)
    if not ob:
        return 0.0
    bids = ob.get('bids') or []
    asks = ob.get('asks') or []
    if not bids or not asks:
        return 0.0
    try:
        current_price = (bids[0][0] + asks[0][0]) / 2.0
    except Exception:
        return 0.0
    bid_depth = sum(amount for price, amount in bids if price >= current_price * 0.98)
    ask_depth = sum(amount for price, amount in asks if price <= current_price * 1.02)
    return float(bid_depth + ask_depth)

# -------- scoring and selection --------
def calculate_immortal_index(stats):
    # defensive math (avoid divide by zero)
    spread = max(stats.get('spread', 0), 0)
    rsi = stats.get('rsi') or 50.0
    volume = max(stats.get('volume', 0), 1.0)
    depth = max(stats.get('depth', 0), 0.0)
    volatility = max(stats.get('volatility', 0.0), 0.0)
    try:
        return (
            0.3 * (1 - spread / 5) +
            0.25 * (rsi / 100 if rsi < 70 else 0.7) +
            0.2 * np.log(volume / 1e6 + 1) +
            0.15 * (depth / 1e6) +
            0.1 * (volatility / 10)
        )
    except Exception:
        return 0.0

def get_pair_stats(symbol):
    ticker = safe_fetch_ticker(symbol)
    if not ticker:
        return None
    ohlcv = safe_fetch_ohlcv(symbol, '1h', limit=100)
    if not ohlcv or len(ohlcv) < 25:
        logger.debug("Insufficient OHLCV for %s", symbol)
        return None
    closes = [c[4] for c in ohlcv]
    volumes = [c[5] for c in ohlcv]
    try:
        bid = ticker.get('bid')
        ask = ticker.get('ask')
        if not bid or not ask or bid == 0:
            return None
        spread = ((ask - bid) / bid) * 100
        volume = sum(volumes[-24:]) if len(volumes) >= 24 else sum(volumes)
        mean_close = np.mean(closes[-24:])
        volatility = (np.std(closes[-24:]) / mean_close * 100) if mean_close != 0 else 0.0
        price_change = ((closes[-1] - closes[-24]) / closes[-24]) * 100 if closes[-24] != 0 else 0.0
        rsi = calculate_rsi_safe(closes)
        depth = calculate_order_book_depth_safe(symbol)
        immortal_index = calculate_immortal_index({
            'spread': spread,
            'rsi': rsi or 50,
            'volume': volume,
            'depth': depth,
            'volatility': volatility
        })
        return {
            'spread': spread,
            'volume': volume,
            'volatility': volatility,
            'price_change': price_change,
            'rsi': rsi or 50,
            'depth': depth,
            'immortal_index': immortal_index,
            'last_price': ticker.get('last', 0.0)
        }
    except Exception as e:
        logger.debug("Error computing stats for %s: %s", symbol, e)
        return None

# -------- selection with limited scope --------
def select_best_pair(limit_markets=50, top_n=19):
    # load markets once per run
    markets = safe_call(exchange.load_markets)
    if not markets:
        return []
    # build candidate symbols ending with /USDT and active
    candidates = [s for s, m in markets.items() if s.endswith('/USDT') and m.get('active', True)]
    logger.info("Found %d candidate USDT pairs (truncating to %d)", len(candidates), limit_markets)
    candidates = candidates[:limit_markets]

    pair_scores = []
    for symbol in candidates:
        stats = get_pair_stats(symbol)
        if stats and stats['volume'] > 1e5:
            pair_scores.append((symbol, stats['immortal_index'], stats))
    pair_scores.sort(key=lambda x: x[1], reverse=True)
    return pair_scores[:top_n]

# -------- dashboard rendering (unchanged styling) --------
CARTMAN_QUOTES = [
    "Screw you guys, I'm going home!",
    "Respect my authoritah!",
    "Whatever, I do what I want!",
    "Beefcake! BEEFCAKE!",
    "I'm not fat, I'm just big-boned!"
]
def cartman_ascii():
    return r"""
       _____
     /  O  O  \
    |   _   |
    |  |_|  |
     \_____/
    """

def generate_live_dashboard(top_pairs):
    layout = Layout()
    layout.split(Layout(name="header", size=3), Layout(name="main"), Layout(name="footer", size=3))
    layout["header"].update(f"[bold yellow]{cartman_ascii()}[/] [blink white]LIVE CRYPTO GLADIATOR ARENA[/]")
    table = Table(title="\nüî• Top Gladiator Pairs (Immortal Index Ranking)", show_header=True)
    table.add_column("Rank", style="cyan"); table.add_column("Pair", style="bold")
    table.add_column("Price", justify="right"); table.add_column("Immortal Index", justify="right")
    table.add_column("RSI", justify="right"); table.add_column("Liquidity Depth", justify="right")
    table.add_column("Spread", justify="right"); table.add_column("Volatility", justify="right")

    for idx, (pair, score, stats) in enumerate(top_pairs, 1):
        rsi_color = "red" if stats['rsi'] > 70 else "green" if stats['rsi'] < 30 else "yellow"
        index_color = "green" if score > 0.7 else "yellow" if score > 0.5 else "red"
        table.add_row(
            str(idx),
            f"[bold]{pair}[/]",
            f"${stats['last_price']:,.4f}",
            f"[{index_color}]üèÜ {score:.2f}[/]",
            f"[{rsi_color}]{stats['rsi']:.1f}[/]",
            f"${stats['depth'] / 1e6:,.1f}M",
            f"{stats['spread']:.2f}%",
            f"{stats['volatility']:.2f}%"
        )
    layout["main"].update(table)
    total_score = sum(p[1] for p in top_pairs) if top_pairs else 0.0
    footer_text = (f"[bold white]{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}[/] | "
                   f"[blink yellow]Market Vitality: {total_score/len(top_pairs) if top_pairs else 0:.2f}[/] | "
                   f"[cyan]{random.choice(CARTMAN_QUOTES)}[/]")
    layout["footer"].update(footer_text)
    return layout

def main():
    console.clear()
    console.print("[bold red]INITIALIZING IMMORTAL TRADING GLADIATOR...[/]")
    time.sleep(1)
    with Live(console=console, screen=True, auto_refresh=False) as live:
        while True:
            try:
                top_pairs = select_best_pair(limit_markets=400, top_n=30)
                live.update(generate_live_dashboard(top_pairs))
                live.refresh()
                time.sleep(6)
            except KeyboardInterrupt:
                console.print("\n[bold red]Stopping...[/]")
                break
            except Exception as e:
                logger.exception("Main loop error: %s", e)
                time.sleep(2)

if __name__ == "__main__":
    main()
